# Tagging: validation and constraints plan

## Overview

We enforce a canonical tag format and known-group rules while allowing users to add new tags dynamically.

- Canonical form is `group:value` (all lowercase). Inputs are normalized (trimmed, lowercased, deduplicated, sorted for determinism).
- Unknown groups and values are allowed. We do not enforce membership in a hardcoded set.
- For known groups defined in our schema, we still enforce behavioral rules like mutual exclusivity.

Implementation details:
- Pydantic validators on `GroundTruthItem.tags` perform normalization and delegate validation to a small tagging service.
- A minimal schema registry and pluggable rules keep behavior declarative and composable (exclusivity, dependencies) for known groups, without rejecting unknowns.

## Files to change

- `app/domain/models.py`
  - Remove tags from here
- `app/domain/enums.py` (new)
  - Move tag enums from `models.py` to here
- `app/domain/tags.py` (new)
  - Add a small schema registry and rules: `TagGroupSpec` (name, values, exclusive, optional dependencies), a `TAG_SCHEMA` dict keyed by group name, and a `RULES` list containing pluggable rule functions/classes (e.g., exclusivity and dependency rules). Values can be sourced from `app/domain/enums.py` to avoid duplication.
- `app/domain/validators.py` (new)
  - Add Pydantic v2 field validators on `GroundTruthItem.tags` to normalize and validate using the schema registry and rules. The validator delegates to `tagging_service.validate_tags` which consumes `TAG_SCHEMA` and `RULES`.
- `app/services/tagging_service.py` (new)
  - Lightweight helpers to format, parse, validate, and upsert tags using the schema registry and rules, without touching models. Keeps logic testable and reusable outside model construction.
- `tests/unit/test_tagging_service.py` (new)
  - Unit tests for helper functions: normalization, validation, exclusivity, and cross-group rules.
- `tests/unit/test_groundtruthitem_tags_validation.py` (new)
  - Unit tests ensuring the `GroundTruthItem` model rejects invalid tags and accepts valid sets.
 - API exposure for frontend (new)
  - Add a small read-only API to expose the tag schema and rules for the frontend to render controls and enforce UX constraints.

Note: We will move tag enums into `app/domain/enums.py` to avoid duplication.

## Tag groups and rules

Canonical tag string format: `group:value`

- Manual tag groups (in TAG_SCHEMA):
  - source: { sme, sa, synthetic, sme_curated, user, other } — mutually exclusive
  - answerability: { answerable, not_answerable, should_not_answer } — mutually exclusive
  - topic: { general, compatibility, part_modeling, fundamentals, sketcher, welding, simulation, cabling, other } — multi-select allowed
  - intent: { informational, action, feedback, clarification, other } — multi-select allowed
  - expertise: { expert, novice } — mutually exclusive
  - difficulty: { easy, medium, hard } — mutually exclusive

- Computed tag groups (generated by plugins, not in TAG_SCHEMA):
  - question_length: { short, medium, long } — computed from question word count
  - retrieval_behavior: { no_refs, single, two_refs, rich } — computed from reference count
  - turns: { singleturn, multiturn } — computed from history length
  - reference_type: { article, document } — computed from reference URLs

Normalization rules:
- Lowercase group and value; trim whitespace; collapse inner whitespace; accept and normalize `group : value` to `group:value`.
- Deduplicate after normalization; sort ascending for deterministic storage.

Validation rules:
- Unknown groups or values are allowed. We only enforce format and known-group rules.
- Exclusive groups (in the known schema) may contain at most one value.

## Schema registry and pluggable rules (near-term)

Goal: minimal code change now, high payoff later by keeping validation declarative and composable.

- Schema registry (`app/domain/tags.py`):
  - `TagGroupSpec` dataclass (or TypedDict):
    - name: str
    - values: set[str] (allowed values)
    - exclusive: bool (mutual exclusivity within the group)
    - depends_on: list[tuple[str, str]] | None (optional group/value dependencies)
  - `TAG_SCHEMA: dict[str, TagGroupSpec]` mapping group -> spec for known groups. Values can be populated from enums in `app/domain/enums.py` to keep a single source of truth for value sets. This is a reference for UX and rule enforcement, not a hard allowlist.
- Rules (`RULES: list[Rule]`):
  - Rule protocol: `check(tags: set[str], schema: dict[str, TagGroupSpec]) -> list[Error]`
  - `ExclusiveGroupRule`: enforces at most one value for groups where `exclusive=True`.
  - `DependencyRule`: requires specified tags when a dependent tag is present (not currently used).
  - Unknown group/value validation can be implemented as a simple pre-check using `TAG_SCHEMA` before applying rules.
- Flow:
  - `tagging_service.validate_tags()` normalizes -> dedupes -> applies all `RULES` (exclusivity, dependency) using `TAG_SCHEMA` for known groups only -> returns canonical list or raises aggregated errors when rules are violated.
  - `app/domain/validators.py` delegates model validation to `tagging_service.validate_tags()` and surfaces errors via Pydantic validation errors.

## OpenAPI exposure for frontend

- Route: `GET /v1/tags/schema`
- Response model (`TagSchemaResponse`):
  - groups: list of objects with
    - name: str
    - values: list[str]
    - exclusive: bool
    - depends_on: list[{ group: str, value: str }] (optional, empty by default)
  - version: str (optional, static for now; future-proofing)
- Implementation:
  - Create a small DTO in `app/api/v1/` (e.g., `schemas.py`) that maps `TAG_SCHEMA` to the response shape.
  - Add a router handler in `app/api/v1/` (e.g., `tags.py`) with `@router.get("/tags/schema", response_model=TagSchemaResponse)` that returns the DTO from the registry.
  - Wire the router into the existing FastAPI app (scaffolding already in place).
- Notes:
  - Keep response stable and deterministic (sort groups by name, values ascending) to simplify caching and CI snapshots.
  - If/when we add rule-specific metadata, we can extend the DTO with a `rules` section (e.g., { type: 'dependency', group: 'x', requires: { group: 'y', value: 'z' } }). For now, `depends_on` is sufficient.
  - The schema lists known groups/values for UX; the backend will still accept unknown groups/values as long as format is valid and rules for known groups are not violated.

## Functions (names and purpose)

In `app/services/tagging_service.py`:

- normalize_tag(tag: str) -> str
  - Lowercase, trim, normalize separator, return canonical `group:value`.
- parse_tag(tag: str) -> tuple[str, str]
  - Split canonical tag into `(group, value)`; raise on invalid format.
- allowed_tag_groups() -> dict[str, set[str]]
  - Returns mapping of group to allowed values using the schema registry (`TAG_SCHEMA`).
- is_exclusive_group(group: str) -> bool
  - Indicates whether the group is mutually exclusive by consulting `TAG_SCHEMA`.
- validate_tags(tags: list[str]) -> list[str]
  - Normalize, dedupe, enforce format, then apply `RULES` (exclusivity and dependency) for known groups using `TAG_SCHEMA`. Unknown groups/values are allowed. Return canonical list or raise aggregated, descriptive errors when rules are violated.
- upsert_tag(tags: list[str], group: str, value: str) -> list[str]
  - Insert or replace the tag for an exclusive group; append for non-exclusive; returns updated canonical tag list.
- remove_group(tags: list[str], group: str) -> list[str]
  - Remove all tags for a group; return canonical list.

In `app/domain/validators.py` (within `GroundTruthItem`):

- field_validator("tags", mode="before")
  - Accept list or comma-separated string; coerce into list of strings.
- field_validator("tags", mode="after")
  - Call `validate_tags` logic (direct or inlined) to return canonical, validated tags; raise `ValueError` on violations.

## Tests (names and coverage)

`tests/unit/test_tagging_service.py`
- test_normalize_tag_trims_and_lowercases
  - Ensures spaces and case normalized to canonical form.
- test_parse_tag_rejects_malformed
  - Non `group:value` strings raise clear error.
- test_validate_tags_allows_unknown_group
  - Unknown group is allowed as long as format is valid.
- test_validate_tags_allows_unknown_value_in_known_group
  - Unknown value within a known group is allowed (rules for the group still apply).
- test_mutual_exclusivity_allows_single_source_only
  - Only one `source:*` allowed at a time.
- test_multi_select_topic_allows_multiple
  - Multiple `topic:*` values accepted.
- test_dedup_and_sort_is_deterministic
  - Duplicates removed and tags sorted consistently.
- test_schema_registry_exposes_expected_groups
  - The schema lists groups and allowed values used by validators.
- test_rules_are_applied_in_validation
  - Validation uses RULES (exclusivity and dependency) to enforce constraints.

`tests/integration/test_tags_schema_api.py`
- test_schema_endpoint_returns_expected_shape
  - Asserts groups array with fields (name, values, exclusive, depends_on) and deterministic sorting.

`tests/unit/test_groundtruthitem_tags_validation.py`
- test_model_accepts_valid_tag_set
  - Valid input persists canonical, sorted tags.
- test_model_allows_unknown_group
  - Model validation accepts an unknown group when format is valid.
- test_model_enforces_exclusive_groups
  - Creating with two `source:*` values fails.
- test_model_allows_multiple_topics
  - Multiple `topic:*` values accepted by model.

## Success criteria

- Canonical storage format is enforced (`group:value`, lowercase, deduped, sorted).
- Unknown groups/values are accepted; known-group rules (exclusivity, dependencies) are enforced.
- Unit tests cover happy paths and edge cases above.
