from __future__ import annotations

from datetime import datetime, timezone
from typing import Optional, cast
from uuid import UUID

from pydantic import BaseModel, Field, ConfigDict, field_validator, model_validator, computed_field

from app.domain.enums import GroundTruthStatus, HistoryItemRole, ExpectedBehavior
from app.domain.validators import GroundTruthItemTagValidators


class Reference(BaseModel):
    """Wire reference object.

    { url, title, content, keyExcerpt, type, bonus, messageIndex }
    """

    url: str = Field(description="Reference URL (required, non-empty)")
    title: str | None = Field(default=None, description="Human-readable title for the reference")
    content: str | None = None
    keyExcerpt: str | None = None
    type: str | None = None
    # Marks a reference as a "bonus"/optional citation for downstream consumers
    bonus: bool = False
    # Which agent turn these refs belong to (optional)
    messageIndex: Optional[int] = None

    @field_validator("url")
    @classmethod
    def validate_url_not_empty(_cls, v: str) -> str:
        if not v or not v.strip():
            raise ValueError("Reference URL cannot be empty")
        return v.strip()


class HistoryItem(BaseModel):
    """Represents a single item in the multi-turn history."""

    model_config = ConfigDict(populate_by_name=True)

    role: HistoryItemRole  # User or Assistant
    msg: str
    refs: Optional[list[Reference]] = None  # References for agent messages
    expected_behavior: Optional[list[ExpectedBehavior]] = Field(
        default=None,
        alias="expectedBehavior",
        description="Expected behavior(s) for this turn in the conversation (e.g., tool:search, generation:answer)",
    )


class GroundTruthItem(GroundTruthItemTagValidators, BaseModel):
    """Canonical Ground Truth item aligned to wire schema (schemaVersion v1).

    All fields with camelCase wire names use aliases; we accept both field names and aliases
    on input (populate_by_name=True) and always serialize using by_alias.
    """

    # Pydantic v2 config
    model_config = ConfigDict(populate_by_name=True)

    # Required core
    # Accept either 'id' or 'uuid' on input; ID is required and generated by the API when missing
    id: str = Field(alias="id")
    datasetName: str = Field(alias="datasetName")
    # UUID bucket assigned at import; optional on inbound until repo assigns
    bucket: Optional[UUID] = None
    status: GroundTruthStatus = GroundTruthStatus.draft
    docType: str = Field(default="ground-truth-item", alias="docType")
    schemaVersion: str = Field(default="v2", alias="schemaVersion")

    # SME/curation
    synth_question: str = Field(alias="synthQuestion")
    edited_question: Optional[str] = Field(default=None, alias="editedQuestion")
    answer: Optional[str] = None
    refs: list[Reference] = cast("list[Reference]", Field(default_factory=list, alias="refs"))

    # Tag fields: manualTags are user-provided, computedTags are system-generated
    manual_tags: list[str] = Field(default_factory=list, alias="manualTags")
    computed_tags: list[str] = Field(default_factory=list, alias="computedTags")

    @computed_field
    @property
    def tags(self) -> list[str]:
        """Return a merged, sorted view of manual and computed tags."""
        merged = set(self.manual_tags or []) | set(self.computed_tags or [])
        return sorted(merged)

    # Free-form curator notes
    comment: Optional[str] = Field(default=None, alias="comment")

    # Multi-turn
    history: Optional[list[HistoryItem]] = None

    # Generation/provenance
    contextUsedForGeneration: Optional[str] = None
    contextSource: Optional[str] = None
    modelUsedForGeneration: Optional[str] = None

    # Sampling fields
    semanticClusterNumber: Optional[int] = None
    weight: Optional[float] = None
    samplingBucket: Optional[int] = None
    questionLength: Optional[int] = None

    # Assignment & audit
    assignedTo: Optional[str] = Field(default=None, alias="assignedTo")
    assigned_at: Optional[datetime] = Field(default=None, alias="assignedAt")
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc), alias="updatedAt"
    )
    updatedBy: Optional[str] = None
    reviewed_at: Optional[datetime] = Field(default=None, alias="reviewedAt")
    etag: Optional[str] = Field(default=None, alias="_etag")
    totalReferences: int = Field(default=0, alias="totalReferences")

    @model_validator(mode="after")
    def compute_total_references_if_needed(self) -> "GroundTruthItem":
        """Auto-compute totalReferences if it's at default (0).

        This ensures totalReferences is correctly populated when items are created
        in memory (e.g., in tests) without going through the repository layer.
        For items loaded from database, this preserves the cached value.
        """
        if self.totalReferences == 0:
            # Count references from history first (multi-turn conversations)
            history_refs = sum(len(turn.refs or []) for turn in (self.history or []))
            if history_refs == 0:
                # Fall back to item-level refs (single-turn)
                self.totalReferences = len(self.refs or [])
            else:
                self.totalReferences = history_refs
        return self


class PaginationMetadata(BaseModel):
    """Pagination metadata for list responses."""

    model_config = ConfigDict(populate_by_name=True)

    page: int = Field(description="Current page number (1-indexed)")
    limit: int = Field(description="Items per page")
    total: int = Field(description="Total number of items matching filters")
    total_pages: int = Field(
        alias="totalPages",
        description="Total number of pages",
    )
    has_next: bool = Field(
        alias="hasNext",
        description="Whether there is a next page",
    )
    has_prev: bool = Field(
        alias="hasPrev",
        description="Whether there is a previous page",
    )


class GroundTruthListResponse(BaseModel):
    model_config = ConfigDict(populate_by_name=True)

    items: list[GroundTruthItem]
    pagination: PaginationMetadata


class AssignmentDocument(BaseModel):
    id: str  # stable id: "<dataset>|<bucket>|<groundTruthId>"
    pk: str  # SME id
    ground_truth_id: str  # ground truth id
    datasetName: str  # dataset name and bucket comprise the GT PK
    bucket: UUID
    # Document metadata
    docType: str = Field(default="sme-assignment", alias="docType")
    schemaVersion: str = Field(default="v1", alias="schemaVersion")


class Stats(BaseModel):
    draft: int = 0
    approved: int = 0
    deleted: int = 0


class BulkImportResult(BaseModel):
    """Result for bulk import operations.

    - imported: number of successfully imported items
    - errors: list of error markers/messages for failed items (order corresponds to failures only)
    """

    imported: int = 0
    errors: list[str] = Field(default_factory=list)


class DatasetCurationInstructions(BaseModel):
    """Dataset-level curation instructions document (schemaVersion v1).

    Stored in the same Cosmos container as ground-truth items using MultiHash PK
    [/datasetName, /bucket] with bucket fixed to 0 and a stable id pattern
    "curation-instructions|{datasetName}".
    """

    # Pydantic v2 config
    model_config = ConfigDict(populate_by_name=True)

    id: str
    datasetName: str = Field(alias="datasetName")
    # Use NIL UUID for dataset-level docs bucket
    bucket: UUID = Field(default_factory=lambda: UUID("00000000-0000-0000-0000-000000000000"))
    docType: str = Field(default="curation-instructions", alias="docType")
    schemaVersion: str = Field(default="v1", alias="schemaVersion")

    instructions: str

    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc), alias="updatedAt"
    )
    updatedBy: Optional[str] = None
    etag: Optional[str] = Field(default=None, alias="_etag")
